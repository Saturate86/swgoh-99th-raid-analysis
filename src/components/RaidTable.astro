---
// This component renders the detailed raid results table
export interface Props {
  allPlayerStats: any[];
  raidData: any[];
}

const { allPlayerStats, raidData } = Astro.props;

// Helper function to get percentage class (matches the JavaScript version)
function getPercentageClass(percentage: number): string {
  if (percentage < 70) return 'status-poor';
  if (percentage < 80) return 'status-warning';
  if (percentage < 95) return 'status-good';
  return 'status-excellent';
}

// Use only the last 5 raids for the detailed table
const last5RaidData = raidData.slice(-5);
const last5RaidDates = last5RaidData.map((raid: any) => raid.date).sort((a: string, b: string) => new Date(a).getTime() - new Date(b).getTime());

// Convert player stats to format needed for raid table
const allPlayersData = allPlayerStats.map((playerStat: any) => {
  const playerData = {
    name: playerStat.name,
    participation: playerStat.participation,
    avgScore: playerStat.avgScore,
    avgEstimate: playerStat.avgEstimate,
    maxEstimated: playerStat.maxEstimated,
    bestScore: playerStat.bestScore,
    efficiency: playerStat.efficiency,
    raids: {} as Record<string, number | null | undefined>
  };
  
  // Map last 5 raids data - only add entries where player was in guild
  const raidsMap: Record<string, number | null | undefined> = {};
  playerStat.last5Raids.forEach((raidEntry: any) => {
    raidsMap[raidEntry.date] = raidEntry.participated ? raidEntry.score : null;
  });
  
  // For dates where player has no entry, set to undefined (not in guild)
  last5RaidDates.forEach((raidDate: string) => {
    if (!(raidDate in raidsMap)) {
      raidsMap[raidDate] = undefined;
    }
  });
  
  playerData.raids = raidsMap;
  return playerData;
});

// Calculate averages for last 5 raids only (only from players who have data for that raid)
const raidAverages: Record<string, number> = {};
for (let raidDate of last5RaidDates) {
  let totalScore = 0;
  let playerCount = 0;
  
  for (let player of allPlayersData) {
    const score = player.raids[raidDate];
    if (score !== undefined && score !== null) {
      totalScore += score;
      playerCount++;
    }
  }
  
  raidAverages[raidDate] = playerCount > 0 ? totalScore / playerCount : 0;
}

// Calculate totals for footer
const totalAvgEstimate = allPlayersData.length > 0 ? 
  (allPlayersData.reduce((sum: number, p: any) => sum + p.avgEstimate, 0) / allPlayersData.length) : 0;

// Calculate total scores for each raid (only players who have data for that raid)
const raidTotals: Record<string, number> = {};
for (let raidDate of last5RaidDates) {
  let total = 0;
  for (let player of allPlayersData) {
    const score = player.raids[raidDate];
    if (score !== undefined && score !== null) {
      total += score;
    }
  }
  raidTotals[raidDate] = total;
}

// Calculate average Avg/Est percentage
const avgAvgEstPercentage = allPlayersData.length > 0 ? 
  (allPlayersData.reduce((sum: number, p: any) => {
    const participatedScores = last5RaidDates
      .map(raidDate => p.raids[raidDate])
      .filter(score => score !== null && score !== undefined);
    const avgRaidScore = participatedScores.length > 0 ? 
      participatedScores.reduce((sum, score) => sum + score, 0) / participatedScores.length : 0;
    const percentage = p.avgEstimate > 0 ? ((avgRaidScore / p.avgEstimate) * 100) : 0;
    return sum + percentage;
  }, 0) / allPlayersData.length) : 0;

// Calculate average Max/Est percentage
const avgMaxEstPercentage = allPlayersData.length > 0 ? 
  (allPlayersData.reduce((sum: number, p: any) => {
    const percentage = p.avgEstimate > 0 ? ((p.bestScore / p.avgEstimate) * 100) : 0;
    return sum + percentage;
  }, 0) / allPlayersData.length) : 0;

// Format date for display - keep ISO format
const formatDate = (dateStr: string) => {
  return dateStr; // Keep original ISO format like 2025-07-09
};

// Sort players by name ascending (default)
const sortedPlayersData = [...allPlayersData].sort((a: any, b: any) => a.name.localeCompare(b.name));
---

<div class="glass-card p-3 sm:p-5 mb-6">
  <h2 class="text-heading mb-3 sm:mb-5 text-center text-sm sm:text-xl">ðŸ“Š Detailed Raid Results (Last 5 Raids)</h2>
  
  <!-- Filter Controls -->
  <div class="mb-4 flex justify-center">
    <label class="flex items-center gap-2 cursor-pointer">
      <input type="checkbox" id="hideIncompleteRaidPlayersFilter" class="sr-only">
      <div class="switch">
        <div class="switch-slider"></div>
      </div>
      <span class="text-gray-300 text-sm">Hide players not in all last 5 raids</span>
    </label>
  </div>
  
  <div class="mobile-scroll-hint">ðŸ‘ˆ Swipe to see all raid dates</div>
  <div class="overflow-x-auto">
    <table id="raidTable" class="w-full border-collapse text-xs sm:text-sm">
      <thead>
        <tr>
          <th onclick="sortRaidTable('name')" class="raid-table-header raid-table-header-sticky cursor-pointer hover:bg-orange-400/30 select-none">
            Player Name <span id="raid-sort-name" class="sort-indicator">â–²</span>
          </th>
          <th onclick="sortRaidTable('avgEstimate')" class="raid-table-header cursor-pointer hover:bg-orange-400/30 select-none">
            Avg Estimate <span id="raid-sort-avgEstimate" class="sort-indicator">â–¼</span>
          </th>
          {last5RaidDates.map((raidDate: string) => {
            const raidAverage = raidAverages[raidDate];
            return (
              <th onclick={`sortRaidTable('${raidDate}')`} class="raid-table-header cursor-pointer hover:bg-orange-400/30 select-none">
                <span set:html={`${formatDate(raidDate)}<br><small class="text-gray-400">(Ã˜ ${new Intl.NumberFormat('de-DE').format(Math.round(raidAverage))})</small>`} />
                <span id={`raid-sort-${raidDate}`} class="sort-indicator">â–¼</span>
              </th>
            );
          })}
          <th onclick="sortRaidTable('avgEst')" class="raid-table-header cursor-pointer hover:bg-orange-400/30 select-none">
            Avg/Avg Est <span id="raid-sort-avgEst" class="sort-indicator">â–¼</span>
          </th>
          <th onclick="sortRaidTable('maxEst')" class="raid-table-header cursor-pointer hover:bg-orange-400/30 select-none">
            Max/Avg Est <span id="raid-sort-maxEst" class="sort-indicator">â–¼</span>
          </th>
        </tr>
      </thead>
      <tbody id="raidTableBody">
        {sortedPlayersData.map((player: any) => {
          const maxEstPercentage = player.avgEstimate > 0 ? ((player.bestScore / player.avgEstimate) * 100) : 0;
          
          // Calculate Avg/Avg Est percentage
          const participatedScores = last5RaidDates
            .map(raidDate => player.raids[raidDate])
            .filter(score => score !== null && score !== undefined);
          const avgRaidScore = participatedScores.length > 0 ? 
            participatedScores.reduce((sum, score) => sum + score, 0) / participatedScores.length : 0;
          const avgEstPercentage = player.avgEstimate > 0 ? ((avgRaidScore / player.avgEstimate) * 100) : 0;
          
          return (
            <tr class="raid-table-row" tabindex="0" data-name={player.name} data-avgestimate={player.avgEstimate} data-avgest={avgEstPercentage} data-maxest={maxEstPercentage}>
              <td class="raid-table-cell raid-table-cell-sticky">{player.name}</td>
              <td class="raid-table-cell raid-table-cell-center">{new Intl.NumberFormat('de-DE').format(Math.round(player.avgEstimate))}</td>
              {last5RaidDates.map((raidDate: string) => {
                const score = player.raids[raidDate];
                
                if (score === undefined) {
                  // Player was not in guild at this time - show gray
                  return <td class="raid-table-cell raid-table-cell-center text-gray-500" data-raid-date={raidDate} data-score="0">-</td>;
                } else if (score === null) {
                  // Player was in guild but didn't participate - show red
                  return <td class="raid-table-cell status-poor" data-raid-date={raidDate} data-score="0">-</td>;
                } else {
                  // Player participated - show with color coding based on their personal efficiency
                  const playerStat = allPlayerStats.find((p: any) => p.name === player.name);
                  const raidEntry = playerStat?.last5Raids.find((r: any) => r.date === raidDate);
                  const estimatedScore = raidEntry?.estimatedScore || 0;
                  const raidEfficiency = estimatedScore > 0 ? ((score / estimatedScore) * 100) : 100;
                  const percentageClass = getPercentageClass(raidEfficiency);
                  
                  return (
                    <td class={`raid-table-cell ${percentageClass}`} data-raid-date={raidDate} data-score={score.toString()}>
                      {new Intl.NumberFormat('de-DE').format(score)} ({raidEfficiency.toFixed(0)}%)
                    </td>
                  );
                }
              })}
              <td class={`raid-table-cell ${getPercentageClass(avgEstPercentage)}`}>
                {avgEstPercentage.toFixed(0)}%
              </td>
              <td class={`raid-table-cell ${getPercentageClass(maxEstPercentage)}`}>
                {maxEstPercentage.toFixed(0)}%
              </td>
            </tr>
          );
        })}
        
        <!-- Footer row with totals -->
        <tr class="raid-table-footer">
          <td class="raid-table-cell raid-table-cell-sticky">ðŸ“Š TOTAL ({allPlayersData.length} players)</td>
          <td class="raid-table-cell raid-table-cell-center">{new Intl.NumberFormat('de-DE').format(Math.round(totalAvgEstimate))}</td>
          {last5RaidDates.map((raidDate: string) => (
            <td class="raid-table-cell raid-table-cell-center">{new Intl.NumberFormat('de-DE').format(raidTotals[raidDate])}</td>
          ))}
          <td class={`raid-table-cell ${getPercentageClass(avgAvgEstPercentage)}`}>
            {avgAvgEstPercentage.toFixed(0)}%
          </td>
          <td class={`raid-table-cell ${getPercentageClass(avgMaxEstPercentage)}`}>
            {avgMaxEstPercentage.toFixed(0)}%
          </td>
        </tr>
      </tbody>
    </table>
  </div>
  <div class="mt-3 sm:mt-4 text-center text-gray-400 text-xs sm:text-sm">
    <!-- Mobile Legend (stacked) -->
    <div class="block sm:hidden space-y-2">
      <p><strong>Legend:</strong></p>
      <div class="flex flex-wrap justify-center gap-1 text-xs">
        <span class="bg-green-500/80 text-white px-2 py-1 rounded whitespace-nowrap">Green = Good (&gt;95%)</span>
        <span class="bg-yellow-500/80 text-white px-2 py-1 rounded whitespace-nowrap">Yellow = Average (80-95%)</span>
      </div>
      <div class="flex flex-wrap justify-center gap-1 text-xs">
        <span class="bg-orange-500/80 text-white px-2 py-1 rounded whitespace-nowrap">Orange = Below Avg (70-80%)</span>
        <span class="bg-red-600/80 text-white px-2 py-1 rounded whitespace-nowrap">Red = Poor (&lt;70%)</span>
      </div>
      <div class="flex flex-wrap justify-center gap-1 text-xs">
        <span class="text-gray-500">Gray = Did Not Participate</span>
      </div>
      <div class="text-xs">
        <span>Avg/Avg Est = Average Score / Average Estimated</span>
      </div>
      <div class="text-xs">
        <span>Max/Avg Est = Best Score / Average Estimated</span>
      </div>
    </div>
    
    <!-- Desktop Legend (inline) -->
    <div class="hidden sm:block">
      <p><strong>Legend:</strong> <span class="bg-green-500/80 text-white px-2 py-1 rounded">Green = Good (&gt;95%)</span> â€¢ <span class="bg-yellow-500/80 text-white px-2 py-1 rounded">Yellow = Average (80-95%)</span> â€¢ <span class="bg-orange-500/80 text-white px-2 py-1 rounded">Orange = Below Average (70-80%)</span> â€¢ <span class="bg-red-600/80 text-white px-2 py-1 rounded">Red = Poor (&lt;70%)</span> â€¢ <span class="text-gray-500">Gray = Did Not Participate</span></p>
      <p class="mt-1">Avg/Avg Est = Average Score / Average Estimated â€¢ Max/Avg Est = Best Score / Average Estimated</p>
    </div>
  </div>
</div>

<script>
  // Load saved sort state from localStorage
  const savedRaidSort = localStorage.getItem('raidTableSort');
  let currentRaidSort = savedRaidSort 
    ? JSON.parse(savedRaidSort) 
    : { column: 'name', direction: 'asc' };

  // Load saved filter state from localStorage
  const savedRaidFilter = localStorage.getItem('raidTableHideIncomplete');
  let hideIncompleteRaidFilter = savedRaidFilter === 'true';

  function saveRaidSortState() {
    localStorage.setItem('raidTableSort', JSON.stringify(currentRaidSort));
  }

  function saveRaidFilterState() {
    localStorage.setItem('raidTableHideIncomplete', hideIncompleteRaidFilter.toString());
  }

  function applyRaidFilter() {
    const tbody = document.getElementById('raidTableBody');
    if (!tbody) return;
    
    const rows = tbody.querySelectorAll('tr:not(.raid-table-footer)');
    
    rows.forEach(row => {
      if (hideIncompleteRaidFilter) {
        // Check if player has data for all raids (no undefined entries)
        const cells = row.querySelectorAll('td[data-raid-date]');
        let hasAllRaids = true;
        
        cells.forEach(cell => {
          // If cell contains "-" and has gray color, it means player wasn't in guild
          if (cell.textContent && cell.textContent.trim() === '-' && cell.classList.contains('text-gray-500')) {
            hasAllRaids = false;
          }
        });
        
        if (hasAllRaids) {
          row.classList.remove('hidden');
        } else {
          row.classList.add('hidden');
        }
      } else {
        row.classList.remove('hidden');
      }
    });
    
    // Fix borders: Remove border from last visible row
    const visibleRows = Array.from(rows).filter(row => !row.classList.contains('hidden'));
    
    // Remove 'last-visible' class from all rows first
    rows.forEach(row => row.classList.remove('last-visible'));
    
    // Add 'last-visible' class to the actual last visible row
    if (visibleRows.length > 0) {
      visibleRows[visibleRows.length - 1].classList.add('last-visible');
    }
  }

  function updateRaidSortIndicators() {
    // Show all indicators with default direction
    document.querySelectorAll('[id^="raid-sort-"]').forEach(indicator => {
      const column = indicator.id.replace('raid-sort-', '');
      
      // Remove active class from all
      indicator.classList.remove('active');
      
      if (column === currentRaidSort.column) {
        // Active column shows current direction
        indicator.textContent = currentRaidSort.direction === 'desc' ? 'â–¼' : 'â–²';
        indicator.classList.add('active');
      } else {
        // Inactive columns show default direction
        if (column === 'name') {
          indicator.textContent = 'â–²'; // Default ascending for name
        } else {
          indicator.textContent = 'â–¼'; // Default descending for numeric/date columns
        }
      }
    });
  }

  function applySortRaidTableWithoutToggle() {
    const tbody = document.getElementById('raidTableBody') as HTMLTableSectionElement;
    const rows = Array.from(tbody.querySelectorAll('tr:not(.raid-table-footer)')) as HTMLTableRowElement[];
    const footerRow = tbody.querySelector('.raid-table-footer') as HTMLTableRowElement;
    
    const multiplier = currentRaidSort.direction === 'desc' ? -1 : 1;
    
    rows.sort((a, b) => {
      let comparison = 0;
      
      switch (currentRaidSort.column) {
        case 'name':
          comparison = (a.dataset.name || '').localeCompare(b.dataset.name || '');
          break;
        case 'avgEstimate':
          comparison = parseFloat(a.dataset.avgestimate || '0') - parseFloat(b.dataset.avgestimate || '0');
          break;
        case 'avgEst':
          comparison = parseFloat(a.dataset.avgest || '0') - parseFloat(b.dataset.avgest || '0');
          break;
        case 'maxEst':
          comparison = parseFloat(a.dataset.maxest || '0') - parseFloat(b.dataset.maxest || '0');
          break;
        default:
          // Handle raid date columns
          const cellIndexA = Array.from(a.cells).findIndex(cell => 
            cell.dataset.raidDate === currentRaidSort.column
          );
          const cellIndexB = Array.from(b.cells).findIndex(cell => 
            cell.dataset.raidDate === currentRaidSort.column
          );
          
          if (cellIndexA !== -1 && cellIndexB !== -1) {
            const scoreA = parseFloat(a.cells[cellIndexA].dataset.score || '0');
            const scoreB = parseFloat(b.cells[cellIndexB].dataset.score || '0');
            comparison = scoreA - scoreB;
          }
          break;
      }
      
      return comparison * multiplier;
    });
    
    // Clear tbody and re-append sorted rows
    tbody.innerHTML = '';
    rows.forEach(row => tbody.appendChild(row));
    // Re-append footer row at the end
    tbody.appendChild(footerRow);
  }

  function sortRaidTable(sortBy?: string) {
    if (sortBy) {
      // Toggle direction if same column
      if (currentRaidSort.column === sortBy) {
        currentRaidSort.direction = currentRaidSort.direction === 'desc' ? 'asc' : 'desc';
      } else {
        currentRaidSort.column = sortBy;
        // Default direction for different column types
        if (sortBy === 'name') {
          currentRaidSort.direction = 'asc';
        } else {
          currentRaidSort.direction = 'desc';
        }
      }
      
      // Save sort state
      saveRaidSortState();
    }

    applySortRaidTableWithoutToggle();
    updateRaidSortIndicators();
  }

  // Initialize with default sort and indicators
  applySortRaidTableWithoutToggle();
  updateRaidSortIndicators();
  
  // Initialize filter and indicators on page load
  document.addEventListener('DOMContentLoaded', function() {
    // Set initial filter state
    const filterCheckbox = document.querySelector('#hideIncompleteRaidPlayersFilter') as HTMLInputElement;
    if (filterCheckbox && filterCheckbox.type === 'checkbox') {
      filterCheckbox.checked = hideIncompleteRaidFilter;
      
      // Add event listener for filter changes
      filterCheckbox.addEventListener('change', function() {
        const checkbox = document.querySelector('#hideIncompleteRaidPlayersFilter') as HTMLInputElement;
        if (checkbox && checkbox.type === 'checkbox') {
          hideIncompleteRaidFilter = checkbox.checked;
          saveRaidFilterState();
          applyRaidFilter();
        }
      });
    }
    
    // Apply initial filter
    applyRaidFilter();
    
    applySortRaidTableWithoutToggle();
    updateRaidSortIndicators();
  });
  
  // Make function globally available
  (window as any).sortRaidTable = sortRaidTable;
</script>
